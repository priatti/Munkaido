<!-- admin-panel.html (drop this anywhere you host your app, e.g. /admin/)
- Minimal admin UI to set roles (free/vip/admin) using Callable Cloud Functions
- IMPORTANT: Fill in your Firebase config below
- Protection: Only users with custom claim { role: 'admin' } OR { admin: true } can use it
--><!doctype html>

<html lang="hu">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>GuriGO – Admin (Roles)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 2rem; }
    .card { border: 1px solid #e5e7eb; border-radius: 12px; padding: 1rem 1.25rem; margin-bottom: 1rem; box-shadow: 0 1px 2px rgba(0,0,0,.05); }
    .row { display: flex; gap: .75rem; align-items: center; flex-wrap: wrap; }
    label { font-weight: 600; }
    input, select, button { padding: .6rem .8rem; border: 1px solid #d1d5db; border-radius: 10px; }
    button { cursor: pointer; }
    .muted { color: #6b7280; font-size: .9rem; }
    .hidden { display: none; }
    .danger { color: #b91c1c; }
    .ok { color: #065f46; }
    code { background: #f9fafb; padding: .15rem .35rem; border-radius: 6px; }
    .table { width: 100%; border-collapse: collapse; margin-top: .5rem; }
    .table th, .table td { text-align: left; padding: .5rem .6rem; border-bottom: 1px solid #eee; }
  </style>
</head>
<body>
  <h1>GuriGO – Admin szerepkezelő</h1>
  <p class="muted">Csak admin jogosultsággal használható. (Claim: <code>role=admin</code> vagy <code>admin=true</code>)</p>  <div id="authCard" class="card">
    <div id="signedOut">
      <div class="row">
        <button id="btnGoogle">Bejelentkezés Google-lel</button>
        <span class="muted">vagy</span>
        <input id="email" type="email" placeholder="Email" />
        <input id="password" type="password" placeholder="Jelszó" />
        <button id="btnEmail">Belépés email/jelszóval</button>
      </div>
    </div>
    <div id="signedIn" class="hidden">
      <div class="row">
        <div>Bejelentkezve: <strong id="userEmail"></strong></div>
        <button id="btnRefresh">Jogosultság frissítése</button>
        <button id="btnSignOut">Kijelentkezés</button>
      </div>
      <div id="adminBadge" class="muted">Jogosultság ellenőrzése…</div>
    </div>
  </div>  <div id="notAdmin" class="card danger hidden">
    Nincs admin jogosultságod ehhez az oldalhoz. Kérj hozzáférést.
  </div>  <div id="tools" class="hidden">
    <div class="card">
      <h2>Felhasználó keresése email alapján</h2>
      <div class="row">
        <input id="searchEmail" type="email" placeholder="pl. user@example.com" />
        <button id="btnSearch">Keresés</button>
      </div>
      <div id="userResult" class="hidden">
        <table class="table">
          <tbody>
            <tr><th>UID</th><td id="r_uid"></td></tr>
            <tr><th>Email</th><td id="r_email"></td></tr>
            <tr><th>Név</th><td id="r_name"></td></tr>
            <tr><th>Jelenlegi claim</th><td id="r_claim"></td></tr>
            <tr><th>Firestore szerep</th><td id="r_roleDoc"></td></tr>
          </tbody>
        </table><div class="row">
      <label for="roleSelect">Új szerep:</label>
      <select id="roleSelect">
        <option value="free">free</option>
        <option value="vip">vip</option>
        <option value="admin">admin</option>
      </select>
      <button id="btnSetRole">Mentés</button>
      <span id="saveMsg" class="muted"></span>
    </div>
  </div>
  <div id="searchMsg" class="muted"></div>
</div>

<div class="card">
  <h2>Gyors tippek</h2>
  <ul>
    <li>Claim beállítás után a felhasználónak újra kell frissítenie a tokenjét (<code>getIdToken(true)</code>),
      vagy ki- és bejelentkezni.</li>
    <li>A változás naplózása a Firestore <code>roles/{uid}</code> dokumentumban történik.</li>
  </ul>
</div>

  </div>  <!-- Firebase SDK (modular) -->  <script type="module">
    // ------------ 1) FILL YOUR CONFIG ---------------
    const firebaseConfig = {
      apiKey: "YOUR_API_KEY",
      authDomain: "YOUR_PROJECT_ID.firebaseapp.com",
      projectId: "YOUR_PROJECT_ID",
      appId: "YOUR_APP_ID",
    };

    // ------------ 2) INIT ----------------------------
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js';
    import { getAuth, onAuthStateChanged, GoogleAuthProvider, signInWithPopup, signInWithEmailAndPassword, signOut } from 'https://www.gstatic.com/firebasejs/10.12.4/firebase-auth.js';
    import { getFunctions, httpsCallable } from 'https://www.gstatic.com/firebasejs/10.12.4/firebase-functions.js';

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const functions = getFunctions(app);

    // UI refs
    const signedOut = document.getElementById('signedOut');
    const signedIn = document.getElementById('signedIn');
    const userEmail = document.getElementById('userEmail');
    const adminBadge = document.getElementById('adminBadge');
    const notAdmin = document.getElementById('notAdmin');
    const tools = document.getElementById('tools');

    // Auth buttons
    document.getElementById('btnGoogle').onclick = async () => {
      await signInWithPopup(auth, new GoogleAuthProvider());
    };
    document.getElementById('btnEmail').onclick = async () => {
      const email = document.getElementById('email').value.trim();
      const pw = document.getElementById('password').value;
      await signInWithEmailAndPassword(auth, email, pw);
    };
    document.getElementById('btnSignOut').onclick = () => signOut(auth);
    document.getElementById('btnRefresh').onclick = async () => {
      if (auth.currentUser) {
        await auth.currentUser.getIdToken(true);
        adminBadge.textContent = 'Jogosultság frissítve.';
        setTimeout(() => adminBadge.textContent = '', 2000);
      }
    };

    // Callable functions
    const findUserByEmailFn = httpsCallable(functions, 'findUserByEmail');
    const setUserRoleFn = httpsCallable(functions, 'setUserRole');

    // Search & set role UI
    const btnSearch = document.getElementById('btnSearch');
    const searchEmail = document.getElementById('searchEmail');
    const userResult = document.getElementById('userResult');
    const saveMsg = document.getElementById('saveMsg');

    btnSearch.onclick = async () => {
      const email = searchEmail.value.trim();
      if (!email) return;
      setLoading('searchMsg', 'Keresés…');
      try {
        const res = await findUserByEmailFn({ email });
        const data = res.data;
        if (!data || !data.uid) {
          setLoading('searchMsg', 'Nincs ilyen felhasználó.', true);
          userResult.classList.add('hidden');
          return;
        }
        document.getElementById('r_uid').textContent = data.uid;
        document.getElementById('r_email').textContent = data.email || '';
        document.getElementById('r_name').textContent = data.displayName || '';
        document.getElementById('r_claim').textContent = JSON.stringify(data.claims || {});
        document.getElementById('r_roleDoc').textContent = data.roleDoc ? JSON.stringify(data.roleDoc) : '—';
        document.getElementById('roleSelect').value = (data.claims && data.claims.role) ? data.claims.role : (data.roleDoc?.role || 'free');
        userResult.classList.remove('hidden');
        setLoading('searchMsg', 'Kész.');
      } catch (e) {
        setLoading('searchMsg', 'Hiba: ' + (e.message || e.code), true);
        userResult.classList.add('hidden');
      }
    };

    document.getElementById('btnSetRole').onclick = async () => {
      const uid = document.getElementById('r_uid').textContent;
      const role = document.getElementById('roleSelect').value;
      if (!uid) return;
      saveMsg.textContent = 'Mentés…';
      try {
        await setUserRoleFn({ uid, role });
        saveMsg.textContent = 'Mentve. Kérd meg a felhasználót token frissítésre.';
        // refresh search to show updated claim
        btnSearch.click();
      } catch (e) {
        saveMsg.textContent = 'Hiba: ' + (e.message || e.code);
      }
    };

    function setLoading(id, text, isErr=false) {
      const el = document.getElementById(id);
      el.textContent = text;
      el.className = isErr ? 'danger' : 'muted';
    }

    // Auth state + admin gate
    onAuthStateChanged(auth, async (user) => {
      if (!user) {
        signedOut.classList.remove('hidden');
        signedIn.classList.add('hidden');
        tools.classList.add('hidden');
        notAdmin.classList.add('hidden');
        return;
      }
      signedOut.classList.add('hidden');
      signedIn.classList.remove('hidden');
      userEmail.textContent = user.email || user.uid;

      // Pull claims
      const token = await user.getIdTokenResult(true);
      const claims = token.claims || {};
      const isAdmin = claims.role === 'admin' || claims.admin === true;
      adminBadge.innerHTML = isAdmin ? '<span class="ok">Admin jogosultság rendben.</span>' : '<span class="danger">Nem admin.</span>';

      if (isAdmin) {
        tools.classList.remove('hidden');
        notAdmin.classList.add('hidden');
      } else {
        tools.classList.add('hidden');
        notAdmin.classList.remove('hidden');
      }
    });
  </script></body>
</html>/* ===================== Cloud Functions ===================== File: functions/index.js

Deploy to your Firebase project (Node 18 runtime recommended)

Provides two callable endpoints:

1. findUserByEmail({ email })

2. setUserRole({ uid, role })  // role in ['free','vip','admin'] */

// functions/index.js const functions = require("firebase-functions"); const admin = require("firebase-admin"); admin.initializeApp();

const db = admin.firestore();

function assertAdmin(context) { if (!context.auth) { throw new functions.https.HttpsError('unauthenticated', 'Sign in required.'); } const c = context.auth.token || {}; const isAdmin = c.role === 'admin' || c.admin === true; if (!isAdmin) { throw new functions.https.HttpsError('permission-denied', 'Only admins allowed.'); } }

exports.findUserByEmail = functions.https.onCall(async (data, context) => { assertAdmin(context); const email = (data && data.email || '').toString().trim(); if (!email) { throw new functions.https.HttpsError('invalid-argument', 'Missing email'); }

try { const userRecord = await admin.auth().getUserByEmail(email); const claims = userRecord.customClaims || {}; let roleDoc = null; try { const snap = await db.doc(roles/${userRecord.uid}).get(); roleDoc = snap.exists ? snap.data() : null; } catch (_) {}

return {
  uid: userRecord.uid,
  email: userRecord.email,
  displayName: userRecord.displayName || '',
  claims,
  roleDoc
};

} catch (e) { // Hide internals throw new functions.https.HttpsError('not-found', 'User not found'); } });

exports.setUserRole = functions.https.onCall(async (data, context) => { assertAdmin(context); const uid = (data && data.uid || '').toString(); const role = (data && data.role || '').toString(); const allowed = ['free','vip','admin']; if (!uid || !allowed.includes(role)) { throw new functions.https.HttpsError('invalid-argument', 'uid/role invalid'); }

// 1) Merge with existing claims const user = await admin.auth().getUser(uid); const existing = user.customClaims || {}; const newClaims = { ...existing, role, admin: role === 'admin' }; // Remove admin flag if role != admin if (role !== 'admin') delete newClaims.admin;

await admin.auth().setCustomUserClaims(uid, newClaims);

// 2) Update roles doc (audit) await db.doc(roles/${uid}).set({ role, assignedBy: context.auth.uid, assignedAt: admin.firestore.FieldValue.serverTimestamp() }, { merge: true });

return { ok: true }; });

/* ===================== package.json ===================== { "name": "functions", "engines": { "node": "18" }, "dependencies": { "firebase-admin": "^12.5.0", "firebase-functions": "^5.0.0" }, "private": true } */

/* ===================== Firestore Rules (snippet) ===================== // Példa: csak VIP vagy admin írhat a /vipContent alá rules_version = '2'; service cloud.firestore { match /databases/{database}/documents { match /vipContent/{doc} { allow read: if request.auth != null; allow write: if request.auth != null && (request.auth.token.role == 'vip' || request.auth.token.role == 'admin'); } } } */